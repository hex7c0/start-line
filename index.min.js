"use strict";

var fs = require("fs"), readline = require("readline"), event = require("events").EventEmitter, inherits = require("util").inherits, eol = require("os").EOL;

function interfac(options, start, end) {
    return end >= 0 ? fs.createReadStream(options.file, {
        flags: options.flag,
        mode: options.mode,
        encoding: options.encoding,
        autoClose: options.autoClose,
        start: start,
        end: end,
        fd: null
    }) : fs.createReadStream(options.file, {
        flags: options.flag,
        mode: options.mode,
        encoding: options.encoding,
        autoClose: options.autoClose,
        start: start,
        fd: null
    });
}

function readlin(options, start, end) {
    return readline.createInterface({
        input: interfac(options, start, end),
        output: null,
        terminal: !1
    });
}

function startline(opt) {
    var file, options = opt || Object.create(null);
    if (!Boolean(options.file)) throw new Error('"file" is required');
    if (file = require("path").resolve(String(options.file)), !fs.existsSync(file)) throw new Error("file does not exist");
    if (!fs.statSync(file).isFile()) throw new Error("path is not a file");
    return new Startline({
        file: file,
        encoding: options.encoding,
        flag: String(options.flag || "r"),
        mode: Number(options.mode) || 444,
        autoClose: !1 !== options.autoClose,
        start: Number(options.start) || 0,
        end: Number(options.end),
        rc4: options.rc4,
        autokey: options.autokey,
        lodash: Boolean(options.autokey)
    });
}

module.exports = startline;

function Startline(options) {
    event.call(this);
    var self = this, temp = "";
    if (this.options = options, this.head = 0, this.tail = 0, this.line = 0, this._stream = null, 
    options.rc4 || options.autokey) {
        var cipher;
        this._stream = interfac(this.options, options.start, options.end), options.rc4 ? (cipher = require("arc4")("arc4", String(options.rc4), options.lodash), 
        this._stream.on("data", function(callbacks) {
            for (var callback = cipher.decodeBuffer(callbacks).toString(), i = 0, ii = callback.length; i < ii; ++i) callback[i] === eol ? (self.tail = self.head + self.line, 
            self.head = self.tail + temp.length, self.emit("line", temp), self.line = 1, temp = "") : temp += callback[i];
            temp.length > 0 && (self.tail = self.head + self.line, self.head = self.tail + temp.length, 
            self.emit("line", temp), self.line = 1);
        })) : (cipher = require("autokey")(String(options.autokey), options.lodash), this._stream.on("data", function(callbacks) {
            for (var callback = cipher.decodeBuffer(callbacks).toString(), i = 0, ii = callback.length; i < ii; ++i) callback[i] === eol ? (self.tail = self.head + self.line, 
            self.head = self.tail + temp.length, self.emit("line", temp), self.line = 1, temp = "") : temp += callback[i];
            temp.length > 0 && (self.tail = self.head + self.line, self.head = self.tail + temp.length, 
            self.emit("line", temp), self.line = 1);
        }));
    } else options.end >= 0 ? (this._stream = interfac(this.options, options.start, options.end), 
    this._stream.on("data", function(callbacks) {
        for (var callback = callbacks.toString(), i = 0, ii = callback.length; i < ii; ++i) callback[i] === eol ? (self.tail = self.head + self.line, 
        self.head = self.tail + temp.length, self.emit("line", temp), self.line = 1, temp = "") : temp += callback[i];
        temp.length > 0 && (self.tail = self.head + self.line, self.head = self.tail + temp.length, 
        self.emit("line", temp), self.line = 1);
    })) : (this._stream = readlin(this.options, options.start, options.end), this._stream.on("line", function(callback) {
        self.tail = self.head + self.line, self.head = self.tail + callback.length, self.emit("line", callback), 
        self.line = 1;
    }));
    this._stream.on("pause", function() {
        return self.emit("pause");
    }).on("resume", function() {
        return self.emit("resume");
    }).on("open", function(fd) {
        return self.emit("open", fd);
    }).on("close", function() {
        return self.emit("close");
    }).on("end", function() {
        return self.emit("end");
    }).on("error", function(err) {
        return self.emit("error", err);
    });
}

inherits(Startline, event), Startline.prototype.pause = function() {
    return this._stream.pause();
}, Startline.prototype.resume = function() {
    return this._stream.resume();
}, Startline.prototype.read = function(start, end) {
    var my = this.options;
    return my.start = Number(start) || 0, my.end = Number(end), new Startline(my);
};
